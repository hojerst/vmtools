#!/bin/bash

set -e

##############################################################################
# functions
##############################################################################
die() {
    echo 1>&2 "ERROR:" "$@"
    exit 1
}

usage() {
    cat <<EOF
NAME
    vmcreate - create a virtual machine from an image

SYNOPSIS
    vmcreate [options] name

OPTIONS
    --disk<x>-size=<size>  size of disk <x>
    --memory=<size>        memory size of domain
    --vcpus=<count>        number of virtual cpus
    --image=<name>         name of image to use
EOF
    exit 1
}

# render a template
render() {
    TEMPLATE="$1"
    shift

    local "$@"

    eval "cat <<TEMPLATE
$(<$TEMPLATE)
TEMPLATE"
}

# parse positional parameter
parsepositional() {
    local pos="$1"
    local arg="$2"

    case "$pos" in
        x)
            NAME="$arg"
            ;;
        *)
            echo 1>&2 "unknown argument: '$arg'"
            exit 1
            ;;
    esac
}

# parse arguments
parseargs() {
    local pos="x"
    local i
    local tmp

    while [ $# -ge 1 ] ; do
        case "$1" in
            --help)
                usage
                ;;
            --disk?-size=*)
                tmp="${1#--disk*}"
                i="${tmp%-size=*}"
                DISKSIZE[$i]="${1##*=}"
                ;;
            --memory=*)
                MEMSIZE="${1##*=}"
                ;;
            --vcpus=*)
                VCPUS="${1##*=}"
                ;;
            --image=*)
                IMAGE="${1##*=}"
                ;;
            --)
                shift
                break
                ;;
            --*)
                echo 1>&2 "unknown option '$1' - ignored."
                ;;
            *)
                parsepositional "$pos" "$1"
                pos="x$pos"
                ;;
        esac
        shift
    done

    # parse remaining positional arguments
    while [ $# -ge 1 ] ; do
        parsepositional "$pos" "$1"
        pos="x$pos"
        shift
    done

    # check if all positional arguments where provided
    if [ "$pos" != "xx" ] ; then
        echo 1>&2 "missing/insufficient arguments."
        echo
        usage
    fi
}

to_bytes() {
    readonly input="$1"
    local size
    case "$input" in
        *b)
            size="${input%*b}"
            echo "$size"
        ;;
        *m)
            size="${input%*m}"
            echo "$((size*1000*1000))"
        ;;
        *g)
            size="${input%*g}"
            echo "$((size*1000*1000*1000))"
        ;;
        *k)
            size="${input%*k}"
            echo "$((size*1000))"
        ;;
        *M)
            size="${input%*M}"
            echo "$((size*1024*1024))"
        ;;
        *G)
            size="${input%*G}"
            echo "$((size*1024*1024*1024))"
        ;;
        *K)
            size="${input%*K}"
            echo "$((size*1024))"
        ;;
        *)
            die "unknown unit in input: '$input'"
        ;;
    esac
}

get_size() {
    local file="$1"

    case "$file" in
        *.gz)
            gzip -l "$file" | sed -e '1d' -e '2 s/  */ /g' -e "2 s/^ //" | cut -f2 -d" "
            ;;
        *)
            wc -c "$file" | sed -e 's/  */ /g' -e "s/^ //" | cut -f1 -d" "
            ;;
    esac
}

get_contents() {
    gzip -dc "$1"
}

get_device() {
    local ALPHA=abcdefghijklmnopqrstuvwxyz
    echo vd${ALPHA:$((i-1)):1}
}

check_disks() {
    local disk
    local minsize
    local i=0

    NUMDISKS=0
    for disk in disk*.img.gz ; do
        [ -e "$disk" ] || break
        [ -r "$disk" ] || die "disk image $disk is not readable"

        minsize="$(get_size "$disk")"
        if [ -z "${DISKSIZE[$i]}" ] ; then
            DISKSIZE[$i]="${minsize}b"
            DISKSIZE_BYTES[$i]="${minsize}"
        else
            DISKSIZE_BYTES[$i]="$(to_bytes "${DISKSIZE[$i]}")"
            if [ "$minsize" -gt "${DISKSIZE_BYTES[$i]}" ] ; then
                die "disk$i must be at least $minsize bytes"
            fi
        fi

        i=$((i+1))
        NUMDISKS=$i
    done
}

create_iso() {
    local iso="$1"
    local src="$2"

    if which hdiutil >/dev/null 2>&1 ; then
        hdiutil makehybrid -volname cidata -o "$iso" "$src" -iso -joliet
    elif which mkisofs >/dev/null 2>&1 ; then
        mkisofs -V cidata -J -o "$iso" "$src"
    else
        die "no iso disk creator found (tried hdiutil and mkisofs)"
    fi
}

##############################################################################
# configuration
##############################################################################
readonly CONFDIR="$HOME/.vmtools"
readonly IMAGEDIR="$CONFDIR/images"

# defaults
POOL=default
MEMSIZE=512M
VCPUS=1

# read config file (if it exists)
if [ -r "$CONFDIR/config" ] ; then
    source "$CONFDIR/config"
fi

# parse arguments
parseargs "$@"

# calculate sizes in bytes
MEMSIZE_BYTES="$(to_bytes "$MEMSIZE")"

##############################################################################
# sanity checks
##############################################################################
[ -z "$IMAGE" ] && die "no --image provided"
[ -d $IMAGEDIR/$IMAGE ] || die "image $IMAGE not found"

[ $MEMSIZE_BYTES -ge 536870912 ] || die "memory size must be at least 512 mb"
[ $VCPUS -ge 1 ] || die "need at least one cpu"

virsh dominfo "$NAME" >/dev/null 2>&1 && die "vm $NAME already exists"

cd "$IMAGEDIR/$IMAGE"
check_disks

for ((i=0; i < $NUMDISKS; i++)) ; do
    virsh vol-info --pool="$POOL" "$NAME-disk$i" >/dev/null 2<&1 && die "disk$i for vm $NAME already exists"
done

virsh vol-info --pool="$POOL" "$NAME-config" >/dev/null 2<&1 && die "config for vm $NAME already exists"

##############################################################################
# summary
##############################################################################
echo "creating vm $NAME:"
echo "  memory: $MEMSIZE ($MEMSIZE_BYTES bytes)"
echo "  cpus:   $VCPUS"
echo "  image:  $IMAGE"
for ((i=0; i < $NUMDISKS; i++)) ; do
    echo "  disk$i:  ${DISKSIZE[$i]} (${DISKSIZE_BYTES[$i]} bytes)"
done

echo
echo "continue [Y/n]? "
read answer
if [ "$answer" != "y" ] && [ "$answer" != "Y" ] && [ "$answer" != "" ] ; then
    exit 0
fi

##############################################################################
# work dir
##############################################################################
WORKDIR=$(mktemp -d /tmp/vmcreateXXXXXX)
trap "rm -rf -- '$WORKDIR'" EXIT

##############################################################################
# main
##############################################################################

echo "creating cloud-init image..."
mkdir "$WORKDIR/config-drive"
NAME=$NAME render "meta-data" >"$WORKDIR/config-drive/meta-data"
NAME=$NAME render "user-data" >"$WORKDIR/config-drive/user-data"

create_iso "$WORKDIR/config.iso" "$WORKDIR/config-drive"

echo "creating cloud-init volume..."
virsh vol-create-as --pool "$POOL" --name "$NAME-config" --capacity $(get_size "$WORKDIR/config.iso") || die "failed to create volume"

echo "uploading cloud-init image..."
virsh vol-upload --pool "$POOL" --vol "$NAME-config" --file "$WORKDIR/config.iso" || die "failed to upload image"

for ((i=0; i < $NUMDISKS; i++)) ; do
    echo "creating disk$i..."
    virsh vol-create-as --pool "$POOL" --name "$NAME-disk$i" --capacity "$DISKSIZE_BYTES" || die "can't create disk volume"
done

for ((i=0; i < $NUMDISKS; i++)) ; do
    echo "uploading image for disk$i..."
    get_contents disk$i.img.gz | virsh vol-upload --pool "$POOL" --vol "$NAME-disk$i" --file /dev/stdin || die "failed to upload image"
done

echo "creating domain..."
NAME=$NAME MEMORY=$MEMSIZE_BYTES VCPUS=$VCPUS render "node.xml" >"$WORKDIR/node.xml"
virsh define "$WORKDIR/node.xml"

echo "attaching cloud-init image to domain..."
path=$(virsh vol-path --pool="$POOL" --vol "$NAME-config")
virsh attach-disk --domain "$NAME" --source "$path" --target hdc --persistent --mode readonly --type cdrom || die "failed to attach disk"

for ((i=0; i < $NUMDISKS; i++)) ; do
    echo "attaching disk$i to domain..."
    diskname="$NAME-disk$i"
    path=$(virsh vol-path --pool="$POOL" --vol "$diskname")
    virsh attach-disk --domain "$NAME" --source "$path" --target $(get_device $i) --persistent || die "failed to attach disk"
done

echo "starting domain..."
virsh start "$NAME"
virsh autostart "$NAME"
